---
layout: assignment
title: Git Fundamentals
---

<h2>Overview</h2>

<p>
This page contains the steps 
that I followed to create
<a href="#">a video discussion of Git fundamentals</a>. 
</p>

<p class="csusbdt-callout">
I am not an expert on Git.
This document and video is for beginners like me to
get started with the process of learning Git.
</p>

<p>
This presentation is based on my reading of 
<a href="http://git-scm.com/book/en/Git-Internals">Chapter 9: Git Internals</a>.
</p>

<p class="csusbdt-callout">
If you are working in Windows, 
the commands given in this tutorial should be performed
in the Git-bash shell.
</p>

<h2>Git Folder Layout</h2>

<p>
Create a new folder named <em>sam</em> 
in your home directory for experimentation.  
</p>

<pre>
cd ~
mkdir sam
cd sam
</pre>

<p>
Create an empty git repository in <em>sam</em>.
</p>

<pre>
git init 
</pre>

<p>
This creates a folder named <em>.git</em> and populates it
with various files and folders.
We will experiment with the essential files under <em>.git</em>.
</p>

<p>
The following files and dirs are inside the .git folder.
</p>

<div class="csusbdt-code-title">Important stuff</div>

<dl class="dl-horizontal csusbdt-box">
  <dt>config</dt>    <dd>configuration (remote urls, ...)</dd>
  <dt>HEAD</dt>      <dd>points to the currently checked out branch</dd>
  <dt>index</dt>     <dd>staging file</dd>
  <dt>objects/</dt>  <dd>raw data</dd>
  <dt>refs/</dt>     <dd>human-readable names of objects</dd>
</dl>

<div class="csusbdt-code-title">Unimportant stuff</div>

<dl class="dl-horizontal csusbdt-box">
  <dt>branches/</dt>    <dd>not used by newer versions of git</dd>
  <dt>description</dt>  <dd>used by something called WebGit</dd>
  <dt>hooks/</dt>       <dd>optional scripts that could be run at different times</dd>
  <dt>info/</dt>        <dd>contains a local excludes file</dd>
</dl>

<p>
View the contents of <em>.git/config</em>.  
It contains the following line.
</p>

<pre>
bare = false
</pre>

<p>
This means the repository is inside a folder that
will be used by a developer working locally.
If bare were set to true, it would indicate that the repository
resides on its own and is used as a remote repository only.
</p>

<h2>Blob objects</h2>

<p>
The SHA-1 hash function maps a block of bytes 
to a 20-byte value called the <em>hash value</em>.
The mapping is considered cryptographically secure because
it would take an unreasonable amount of time to determine
the block of bytes that produced a given hash value.
But this isn't the property that Git relies on.
For Git to work correctly,
there should be no collisions,
which means there should never be 2 different objects that map to the same hash value.
There is no publicly known SHA-1 collision even through researchers have tried to produce one.
Thus, I believe the possibility of a collision is so small that the issue can be ignored.
</p>

<p>
Git stores various types of objects in its datastore.
When Git stores a file,
the object type is considered a <em>blob</em>.
The name of a blob object is computed
as the SHA-1 hash of the ASCII string <code>"blob "</code>, 
followed by an ASCII string representation of the filesize,
followed by a zero byte,
followed by the file contents.
The result is a 20-byte number that can be used to locate
the object in the datastore.
Because the keys of blob objects in the datastore are computed from the
data they contain, Git is referred to as a 
<em>content-addressable file system</em>.
</p>

<p class="csusbdt-callout">
A 20-byte number is represented using 40 hexidecimal characters.
</p>

<p>
In the <em>sam</em> folder, create a file named <em>hello.txt</em> 
with the text <em>hello</em> stored in it.
</p>

<pre>
echo hello > hello.txt
</pre>

<p>
Use the <code>git hash-object</code> command as follows
to compute the git hash name for the contents of <em>hello.txt</em>.
</p>

<pre>
git hash-object hello.txt
</pre>

<p>
This command displays the following hash 
computed from a concatenation of meta data and file contents.
</p>

<pre>
ce013625030ba8dba906f756967f9e9ca394464a
</pre>

<p>
The <code>git hash-object</code> command computes the SHA-1 hash of
of a file using the following process.
</p>

<pre>
Git hash = SHA1("blob " + <em>file size</em> + "\0" + <em>file contents</em>)
</pre>

<p>
To see this, run the following command
and verify that it produces the same hash 
as the <code>git hash-object</code> command.
</p>

<pre>
printf "blob 6\0hello\n" | openssl sha1
</pre>

<p>
I haven't checked if this works under Windows.
On Linux use <code>sha1sum</code> instead of <code>openssl sha1</code>.
</p>

<p>
Use the <code>-w</code> option
to write the blob object into the datastore.
</p>

<pre>
git hash-object -w hello.txt
</pre>

<p>
Git stores the blob object as a file under the following folder.
</p>

<pre>
.git/objects/ce
</pre>

<p>
Notice that the first 2 characters of the hash 
are taken for the folder name
and the remaining 38 characters of the hash
are used for the filename.
</p>

<p>
Use the <code>git cat-file</code> command 
with the <code>-t</code> option to display
the type of object stored under a given hash.
</p>

<pre>
git cat-file -t ce01
</pre>

<p class="csusbdt-callout">
When using hash identifiers in Git,
you can specify as few as 4 characters,
but you need to include enough to distinguish the hash
from all others in the datastore.
In our example, the string <code>ce01</code> is a sufficient
abbreviation for <code>ce013625030ba8dba906f756967f9e9ca394464a</code>. 
</p>

<p>
The above command displays the following.
</p>

<pre>
blob
</pre>

<p>
Use the  
<code>-p</code> option as follows 
to inspect the contents of a git object.
</p>

<pre>
git cat-file -p ce01
</pre>

<p>
The above command displays the following.
</p>

<pre>
hello
</pre>

<p>
Git objects contain a header followed by a zlib-compressed version of the data.
The header contains an object type indicator (<em>blob</em> for files) 
and the byte length of the uncompressed data.
</p>

<h2>Tree objects</h2>

<p>
Git stores folders as tree objects.
For the purpose of illustration, 
create file <em>bye.txt</em> with contents <em>bye</em>.
</p>

<p>
Store <em>bye.txt</em> in Git's object store.
</p>

<pre>
git hash-object -w bye.txt
</pre>

<p>
Git displays its SHA-1 hash for the file.
</p>

<pre>
b023018cabc396e7692c70bbf5784a93d3f738ab
</pre>

<p>
Git produces tree objects from a file named </em>index</e>.
Check under <em>.git</em> that the index file doesn't yet exist.
</p>

<pre>
ls .git/index
</pre>

<p>
As a first step, use the <code>git update-index</code> command 
to create the index and add <em>hello.txt</em> to it.
</p>

<pre>
git update-index --add hello.txt
</pre>

<p>
Verify that <em>.git/index</em> now exists.
</p>

<pre>
ls .git/index
</pre>

<p>
Let's add another file to the index.
Run the following to add <em>bye.txt</em> to the index.
</p>

<pre>
git update-index --add bye.txt
</pre>

<p>
Use <code>git write-tree</code> 
to write the index into the object store as a tree object.
</p>

<pre>
git write-tree
</pre>

<p>
The <code>write-tree</code> command 
displays the following SHA-1 hash 
that identifies the tree object in the object store.
</p>

<pre>
02671cb81375cd06bc56f0c4f94064afe5324bbc
</pre>

<p>
Verify that the newly created object is a tree object.
</p>

<pre>
git cat-file -t 0267
</pre>

<p>
Look at the contents of the tree object.
</p>

<pre>
git cat-file -p 0267
</pre>

<p>
This command displays the following.
</p>

<pre>
100644 blob b023018cabc396e7692c70bbf5784a93d3f738ab    bye.txt
100644 blob ce013625030ba8dba906f756967f9e9ca394464a    hello.txt
</pre>

<p>
From this, you can see that git tree objects contain a list of objects,
which include each object's permissions, type, hash and filename.
</p>

<p>
Let's see what a folder looks like when placed in the repository.
Because you can only add files into the index, we need
to have a file in the folder that we want to test.
</p>

<p>
Create a folder called <em>test</em> 
and copy <em>bye.txt</em> into it.
</p>

<p>
Add <em>test/bye.txt</em> into the index.
</p>

<pre>
git update-index --add test/bye.txt
</pre>

<p>
Write the index into the object store.
</p>

<pre>
git write-tree
</pre>

<p>
This displays the following hash for the new tree object.
</p>

<pre>
e2265495a2b7c2572d86a2dc7abf64280f05cd08
</pre>

<p>
Verify the new tree object is in the data store.
</p>

<pre>
ls .git/objects
</pre>

<p>
Verify the type of the new tree object.
</p>

<pre>
git cat-file -t e226
</pre>

<p>
Verify the contents of the new tree object.
</p>

<pre>
git cat-file -p e226
</pre>

<p>
This produces the following output.
</p>

<pre>
100644 blob b023018cabc396e7692c70bbf5784a93d3f738ab    bye.txt
100644 blob ce013625030ba8dba906f756967f9e9ca394464a    hello.txt
040000 tree b72ea0f9eb903bf5f9eebd9150a001878fd9d337    test
</pre>

<p>
Notice that the test folder is represented as a tree object with
a hash value that we have not seen yet. Examine the contents
of the test tree object.
</p>

<pre>
git cat-file -p b72e
</pre>

<p>
This produces the following output.
</p>

<pre>
100644 blob b023018cabc396e7692c70bbf5784a93d3f738ab    bye.txt
</pre>

<p>
This is a very interesting result.
The <em>bye.txt</em> file in the <em>test</em> folder has the same
hash as the <em>bye.txt</em> file in the root folder.  
Because these files are identical, 
the two tree objects that reference them point to the
same blob object.
</p>

<p>
Change the contents of <em>hello.txt</em> to something else.
</p>

<p>
Use the <code>cat-file</code> command as follows
to restore the previous contents of <em>hello.txt</em>.
</p>

<pre>
git cat-file -p ce01 > hello.txt
</pre>

<h2>Commit objects</h2>

<p>
So far, we have looked at blob and tree objects.
In this section, we will investigate commit objects.
A commit object represents a snapshot of the state of the working tree.
The commit object contains the following pieces of information.
</p>

<ul>
<li>the hash value of the tree object that was
    created out of the index</li>
<li>a comment</li>
<li>a timestamp</li>
<li>name of the committer</li>
</ul>

<p>
Use the <code>commit-tree</code> command as follows to
create a commit object for the top-level tree object
previously created.
</p>

<pre>
echo "first commit" | git commit-tree 0267
</pre>

<p>
Notice that the <code>git commit-tree</code> command
takes the hash for a top-level tree object
but gets its comment from the standard input stream.
The above command displays the following hash for the commit objected.
</p>

<pre>
7f62b53548a8d6df5d49238c1023fdf6650c9fb0
</pre>

<p>
Use the <code>git cat-file</code> with the <code>-t</code>
argument to see that the hash refers to a commit object.
</p>

<pre>
git cat-file -t 7f62
</pre>

<p>
Use the <code>-p</code> argument to 
display the contents of the commit object.
</p>

<pre>
git cat-file -p 7f62
</pre>

<p>
The commit object just created starts a branch 
because it has no parent.
Let's create a second commit object in this branch
by using the <code>-p</code> argument to specify a parent.
</p>

<pre>
echo "second commit" | git commit-tree e226 -p 7f62
</pre>

<p>
The hash value of the second commit is the following.
</p>

<pre>
f52a559d24982751d9427b9fcafe83c8c8342d93
</pre>

<p>
Examine the commit log.
</p>

<pre>
git log --stat f52a
</pre>

<h2>Refs and branches</h2>

<p>
Git provides a naming mechanism
to make it easier to work with commits. 
Named git hash values are referred to as <em>refs</em> 
and are stored under <em>.git/refs</em>.
</p>

<p>
A branch is not neccessarily a simple sequence of commits
because merge operations 
may result in commit objects with multiple parents.
In fact, a branch is a directed graph of commits 
that culminate at a single commit object
referred to as its head. 
</p>

<p>
Git stores refs to branch heads under <em>.git/refs/heads</em>.
The ref name is the name of the branch.
</p>

<p>
The following command
creates a ref that points to the last commit 
and makes it the head of
a branch called <code>master</code>.
</p>

<pre>
git update-ref refs/heads/master f52a559d24982751d9427b9fcafe83c8c8342d93
</pre>

<p>
Now you can use the string <code>master</code> 
instead of the hash value in commands. 
The following shows that this works 
with the <code>git cat-file</code> command.
</p>

<pre>
git cat-file -p master
</pre>

<p>
Directly under <em>.git</em> is a file called <em>HEAD</em>. 
It contains a ref for the
branch that is currently checked out.
</p>

<pre>
cat .git/HEAD
</pre>

<p>
The above command displays the following.
</p>

<pre>
ref: refs/heads/master
</pre>

<p>
The following command creates a file named
<em>test</em> in the heads folder
with contents equal to the git hash for the first commit object we created.
Creating this file establishes a branch
branch called <em>test</em> 
whose head is also the first commit of the master branch.
</p>

<pre>
echo "7f62b53548a8d6df5d49238c1023fdf6650c9fb0" > .git/refs/heads/test
</pre>

<p>
Display a list of branches.
</p>

<pre>
git branch
</pre>

<p>
This displays the following.
</p>

<pre>
* master
  test
</pre>

<p>
The asterisk shows the current branch.
Verify this as follows.
</p>

<pre>
cat .git/HEAD
</pre>

<p>
The current branch is the branch operated on when staging and committing.
</p>

<p>
Use the <code>git checkout</code> command 
to replace the working tree 
with a specified tree object.
Do the following to set the contents of <em>sam</em> 
to the head of the test branch.
</p>

<pre>
git checkout test
</pre>

<p>
Notice that the test folder is gone.
</p>

<p>
Check that <em>test</em> is the current branch.
</p>

<pre>
git branch
cat .git/HEAD
</pre>

<p>
Let's manually delete the test branch 
and recreate it using the <code>git branch</code> command.
</p>

<p>
Checkout the master branch.
</p>

<pre>
git checkout master
</pre>

<p>
Manually delete the test branch.
</p>

<pre>
rm .git/refs/heads/test
</pre>

<p>
Verify that master is the only branch.
</p>

<pre>
git branch
</pre>

<p>
Checkout the first commit.
</p>

<pre>
git checkout 7f62
</pre>

<p>
Git tells us we are in <em>detatched head mode</em>.  
This means the HEAD ref
points to a commit but not to a branch head. 
Verify this as follows.
</p>

<pre>
cat .git/HEAD
</pre>

<p>
This fact can also be verified 
with the <code>git branch</code> command.
</p>

<pre>
git branch
</pre>

<p>
Do the following to create a new branch called <em>test</em> 
with head pointer equal to the current HEAD.
</p>

<pre>
git branch test
</pre>

<p>
See that the new branch exists.
</p>

<pre>
git branch
</pre>

<p>
However, we are still in detatched head mode. 
To make <em>test</em> the current branch,
run the <code>git checkout</code> command.
</p>

<pre>
git checkout test
</pre>

<p>
Finally, we will repeat the process 
of creating a test branch but do it using the
<code>git checkout</code> command.
</p>

<p>
Delete the test branch.
</p>

<pre>
git checkout master
git branch -d test
</pre>

<p>
Verify.
</p>

<pre>
git branch
</pre>

<p>
Recreate the test branch.
</p>

<pre>
git checkout -b test 7f62
</pre>

<p>
Verify that <em>test</em> is a new branch and is current.
</p>

<pre>
git branch
</pre>

<h2>The tag object</h2>

<p>
A fourth type of git object is called a <em>tag</em>. 
A tag is a pointer to a commit 
with timestamp, message and identification of the creator.
</p>

<p>
Verify that there are no tags.
</p>

<pre>
ls .git/refs/tags
</pre>

<p>
The following creates a tag called <em>v1</em> 
that points to the head of the master branch.
</p>

<pre>
git checkout master
git tag v1
</pre>

<p>
Verify that the tag was created.
</p>

<pre>
ls .git/refs/tags
cat .git/refs/tags/v1
</pre>

<p>
Verify that the tag points to the same commit object as the head
of the master branch.
</p>

<pre>
cat .git/refs/heads/master
</pre>

<p>
The tag <em>v1</em> is an example of a lightweight tag, 
which is a reference to a commit. 
An annotated tag, on the other hand, 
is a reference to a tag object.
This allows the tag to be associated 
with a comment, tagger and timestamp.
The following is an example of an annotated tag.
</p>

<pre>
git tag -a av1 master -m "version 1"
</pre>

<p>
Check that a tag object got created.
</p>

<pre>
cat .git/refs/tags/av1
</pre>

<p>
This displays the following.
</p>

<pre>
4714bb773733f8052bfcaf45224720d4f179a518
</pre>

<p>
Check the type of object the hash names.
</p>

<pre>
git cat-file -t 4714
</pre>

<p>
Another thing to keep in mind is that
tags don't need to point to commit objects; 
they can point to any type of git object.
</p>

<h2>Remote References</h2>

<p>
In addition to branch heads and tags, 
a third type of reference is a remote reference.
A remote ref is a hash for an object in a remote repository.
</p>

<p>
For example, suppose you push the master branch 
to a remote called <em>origin</em>. 
In this case, git sets the following 
to the hash of the local master branch head.
</p>

<pre>
.git/refs/remotes/origin
</pre>

<p>
Remote refs can not be checked out like local refs; 
they can only be merged into 
local branches. (Is this correct?)
</p>

<p>
TODO: experiments on remote refs
</p>

<h2>Packing</h2>

<p>
When you run <code>git gc</code> 
or when this is run as a side effect of pushing to a remote,
git will try to pack the objects in such a way 
that similar sections of data are extracted
and pointed to by multiple containing objects. 
The result is that files under
<em>.git/objects</em> get removed 
and added in another form under <em>.git/objects/pack</em>.
</p>

<p>
NOTE TO MYSELF: Resume reading and note taking from 
<a href="http://git-scm.com/book/en/Git-Internals-The-Refspec">here</a>.
</p>

