---
layout: assignment
title: Caching Assignment
---

<div class="csusbdt-video-btn">
  <a class="btn btn-success" role="button" target="_blank" href="http://youtu.be/c26ukiDbuBI">Video</a>
</div>

<h2>Overview</h2>

<p>
The purpose of this assignment 
is to learn about HTTP caching mechanisms 
and how to make use of them 
in a single-page web application. 
A good place to start is by reading 
<a href="http://www.mnot.net/cache_docs/">Caching Tutorial</a>.
</p>

<p>
Retrieving data from the Internet 
is slow relative to retrieving 
from the local file system.  
Also, retrieving data over the Internet 
will consume bandwidth, 
which is a cost for the application provider and user. 
Because many Web accessible resources, 
such as HTML, images, video, etc., 
don't change frequently, 
it makes economic sense to retrieve 
these resources once over the network, 
store them in the local file system, 
and then read them from the file system when needed subsequently. 
This process can be called <em>local caching</em>.
</p>

<p>
There are 2 places where caching of HTTP data can occur:
</p>

<ul>
<li>on the local computer by the browser, as just described, and</li>
<li>on a remote computer, called a cache server, 
    that is controlled by your Internet service provider,
    application provider, or other intermediary
    interested in conserving bandwidth.</li>
</ul>

<p>
The HTTP protocol includes headers 
that can be used by client and server 
to exchange information that is relevant to caching. 
For instance, some resources should not be cached 
because they are changing. 
In this case, we would include cache controlling headers 
to the request URL to ensure 
that the resource is never delivered from cache storage.
To guard against aggressive caches that might ignore these headers,
one can add a random string to the request URL
so that the cache sees repeated requests as distinct.
</p>

<p>
This assignment will illustrate the following 2 techniques.
</p>

<ul>
<li>How to turn on caching through the use of ETags.</li>
<li>How to turn off caching.</li>
</ul>

<h2>Assignment Folder</h2>

<p>
Create a directory named <em>cache</em> 
for the work you do for this assignment. 
At the end of the assignment, 
this folder will contain the following files.
</p>

<ul>
<li>app.html</li>
<li>main.js</li>
<li>root.js</li>
<li>image.js</li>
<li>message.js</li>
<li>response.js</li>
</ul>

<h2>Experiment with ETags</h2>

<p>
Servers can optionally return an ETag header 
for objects they return to requesting clients.
The ETag header contains a string 
that identifies the version of the object being returned.
In this section,
you will perform experiments with curl
to get a better understanding of how ETags work.
</p>

<p>
Use curl as follows
to view the HTTP response headers 
when requesting <em>http://curl.haxx.se/</em>.
</p>

<pre>
curl -X GET http://curl.haxx.se/ -I
</pre>

<p>
These are the headers that I got.
</p>

<pre>
HTTP/1.1 200 OK
Date: Wed, 27 Nov 2013 01:54:08 GMT
Server: Apache/2.4.6 (Debian)
Last-Modified: Wed, 27 Nov 2013 01:45:05 GMT
ETag: "2d66-4ec1ebf09370e"
Accept-Ranges: bytes
Content-Length: 11622
Vary: Accept-Encoding
Content-Type: text/html
</pre>

<p>
Notice the ETag header. 
If a browser caches the content 
returned from a request with an ETag header,
then it should also store the ETag value with it.
The next time the user navigates to the page,
the browser should include an <code>If-None-Match</code>
header with the ETag of the cached page
to let the server know which version of the page it has cached.
In our example, this header would look like the following.
</p>

<pre>
If-None-Match: "2d66-4ec1ebf09370e"
</pre>

<p>
If the document at the server has not been revised since the last request,
then the ETag will not have changed.
In this case the server returns a <em>304 Not modified</em> response.
The following command uses the <code>-H</code>
option of curl to add an <code>If-None-Match</code> header
to the request message.
</p>

<pre>
curl -X GET http://curl.haxx.se/ -I -H "If-None-Match: \"2d66-4ec1ebf09370e\""
</pre>

<p>
When I ran this command,
I got the following response.
</p>

<pre>
HTTP/1.1 304 Not Modified
Date: Wed, 27 Nov 2013 01:56:53 GMT
Server: Apache/2.4.6 (Debian)
ETag: "2d66-4ec1ebf09370e"
</pre>

<p>
The server responded with a <code>304</code> code
to let me know that my cached version of the data is current.
When you try the above command,
make sure that you set the ETag 
to the one you retrieved from the server.
</p>

<p>
To see the result of sending a non-matching ETag, 
try to the following.
</p>

<pre>
curl -X GET http://curl.haxx.se/ -I -H "If-None-Match: 1234"
</pre>

<p>
When I ran this command,
I got the following response.
</p>

<pre>
HTTP/1.1 200 OK
Date: Wed, 27 Nov 2013 01:59:23 GMT
Server: Apache/2.4.6 (Debian)
Last-Modified: Wed, 27 Nov 2013 01:45:05 GMT
ETag: "2d66-4ec1ebf09370e"
Accept-Ranges: bytes
Content-Length: 11622
Vary: Accept-Encoding
Content-Type: text/html
</pre>

<p>
Notice that the server returns a 200 response code,
which means it has included the document in the body of the response.
Also observe that the server includes an ETag header that identifies
the current version of the document.
The server wants me to replace what I currently have stored 
with the new data and to store the new ETag along with it.
</p>

<p>
The concept of an ETag is identical to the concept of a version identifier.
</p>

<h2>Turn Caching On</h2>

<p>
This section is focused on controlling caching through ETags.
Another common way to control caching is with expiration times,
but this is not covered in this assignment.
</p>

<p>
You should start 
by making a copy of all the files from 
<a href="json.html">the json assignment</a>. 
This will be the starting point for the remaining
experiments in this assignment.
</p>

<p>
The following code uses the SHA-1 hash function
to generate an ETag based on the contents of a buffer.
Here, we rely on SHA-1 to generate unique labels
for all data to be cached.
</p>

<pre>
function generateETag(buffer) {
  var shasum = require('crypto').createHash('sha1');
  shasum.update(buffer, 'binary');
  return shasum.digest('hex');
}
</pre>

<p>
You should add the function <code>generateETag</code> 
to the root module <em>root.js</em>
and call it in its <code>init</code> function
to generate the ETag for the current contents of <em>app.html</em>.
</p>

<p>
Generating ETags from file contents is convenient 
because the ETags will take on new values when files change. 
</p>

<p>
Also, add code 
that checks the ETag sent by the browser.
If the supplied ETag matches the ETag for app.html, 
then return a <em>304 Not modified</em> response.
If the ETag does not match, 
then return the new contents of <em>app.html</em> 
and the new ETag value.
</p>

<p>
The following function shows how to return a <em>304 Not modified</em> response. 
</p>

<pre>
replyNotModified = function(res) {
  res.writeHead(304);
  res.end();
};
</pre>

<p>
If in your code <code>etag</code> represents the ETag
for <em>app.html</em>,
then the following code makes this check and passes
control to replyNotModified if the browser's stored ETag matches 
the current ETag.
</p>

<pre>
if (req.headers['if-none-match'] === etag) {
  console.log('returning 304');
  return replyNotModified(res);
}
</pre>

<p>
After making these changes to the root module,
run the server and test that the caching mechanism works as expected.
Use a Web traffic inspection tool 
to see if your browser checks the ETag 
for requests it makes after retrieving the root resource. 
When you do this, make sure that caching is turned on.
</p>

<p>
Caching by browsers is optional so your browser may choose not
to store the object and its ETag. 
Safari in particular might not respect the ETag you send it.
If this is the case with your browser then
try a different browser.
Alternatively, use curl 
in the same way that we used it to experiment with
<em>http://curl.haxx.se/</em>.
</p>

<p>
As an additional experiment,
change the contents of <em>app.html</em> in some way,
then restart the server and
verify that the browser retrieves the new version of the Web page.
Also verify that subsequent requests for the Web page
result in reliance on the local cache.
</p>

<p>
Modify your application so that
ETags are also sent with your image.
</p>

<p>
Notice that the <code>generateETag</code> and <code>replyNotModified</code>
functions are needed in both <code>root.js</code> and <code>image.js</code>.
Create a new module named <code>response.js</code>
to contain functions that will be accessed from more than
one request handling module.
Place <code>generateETag</code> and <code>replyNotModified</code> 
in <code>response.js</code>
and from <code>root.js</code> and <code>image.js</code>.
</p>

<h2>Turn Caching Off</h2>

<p>
In this part of the assignment,
you will ensure that the browser (and any remote caches)
do not cache data retrieved via ajax.
</p>

<p>
Some browsers cache responses to Ajax requests even when using the POST method.
See <a href="http://stackoverflow.com/questions/12506897/is-safari-on-ios-6-caching-ajax-results">Is
  Safari on iOS 6 caching $.ajax results?</a>
For this reason, you should always add a random value to the query string of the URL
used with the request message.
The request handler on the server should simply ignore this value.
</p>

<p>
If you set <code>x</code> to the result of calling
the Javascript function <code>Math.random</code> in the query string part of the URL,
then you will end up with an HTTP request similar to the following.
</p>

<pre>
POST /message?x=0.123456789 HTTP/1.1
</pre>

<p>
For the purpose of this assignment
assume that the ajax message returned by the server should never be cached.
Do the following 3 things to increase the likelihood the response is not cached.
</p>

<ul>
<li>Add the <code>Pragma: no-cache</code> header to your response.</li>
<li>Add the <code>Cache-Control: no-cache, no-store</code> header to your response.</li>
<li>Add a random value to the query string component of the URL sent with the request message.</li>
</ul>

<p>
Use a Web traffic inspection tool to verify that the browser always retrieves the message.
</p>

<p>
Adding a random value to the query string of the request URL
is probably sufficient to keep the browser from using cached data.
However, it's nice to include the headers because they
keep the browser from unnecessary caching.
</p>

