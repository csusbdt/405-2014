---
layout: assignment
title: Events Assignment
---

<div class="csusbdt-video-btn">
  <a class="btn btn-success" role="button" target="_blank" href="http://youtu.be/ZpgXlXY2J0M">Video</a>
</div>

<h2>Overview</h2>

<p>
The purpose of this assignment is to better understand 
<a href="http://nodejs.org/api/all.html#all_events">events in Node.js</a>.
</p>

<p>
Events in server-side Node.js are different than 
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Event">events in client-side Web pages</a>,
which you also need to learn about, 
but are not covered in this assignment.
</p>

<h2>Assignment folder</h2>

<p>
Create a directory named <code>event</code> in your repository 
to hold the work for this assignment. 
When you complete this assignment, the contents of this folder will be the following.
</p>

<ul>
<li>test_instanceof.js</li>
<li>test_domain.js</li>
<li>main.js</li>
</ul>

<h2>EventEmitter</h2>

<p>
In Node.js, objects that emit events are 
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof">instances of</a>
EventEmitter. 
Node's HTTP server is an example of an event emitter.
You can see this from the following code.
</p>

<pre>
var http = require('http');
var EventEmitter = require('events').EventEmitter;
var server = http.createServer();
console.log(server instanceof EventEmitter);
</pre>

<p>
Place the above code in a file named <em>test_instanceof.js</em>
and run and test that it prints true.
Modify the code so that it
follows the pattern presented in 
<a href="assert.html">the assert assignment</a>.
The program should simply print <em>All tests passed</em> when it runs.
Use strict equality <code>===</code> in your assert statements.
</p>

<p>
The next bit of code shows 
how to register an event listener function with a server object
created by <code>http.createServer()</code>.
</p>

<pre>
function requestListener(req, res) {
  console.log('Handling request for ' + req.url);
  res.end('hello');
}

server.on('request', requestListener);
</pre>

<p>
The first argument in the <code>on</code> function 
is the name of an event 
and the second argument is a reference 
to a function that is called when the event occurs. 
In our case, the event we listen for is called <code>request</code>,
which occurs when a browser makes a TCP connection 
to the port the server is listening to 
and sends an HTTP request message. 
</p>

<p>
The request event listener function takes 2 arguments: 
a request object <code>req</code> and a response object <code>res</code>. 
The request object is used to read the HTTP message data sent by the browser
and the request object is used to construct 
and send an HTTP response message back to the browser.
</p>

<p>
There is one more thing we need to do to get a running server: 
tell the server to list to a port. 
Add the following line to do this.
</p>

<pre>
server.listen(5000);
</pre>

<p>
Assemble the above code snippets into a complete server.
Place the code in a file named <code>main.js</code>.
Do not include the assertion that <code>server</code> 
is an instance of <code>EventEmitter</code>.
Run the code and go to 
<a href="http://localhost:5000">http://localhost:5000</a> 
with a browser to test.
</p>

<p>
Your browser may send 2 requests, 
one for <em>/</em> and the other for <em>/favicon.ico</em>. 
The favicon file is used by browsers as a graphical icon to represent the site,
and it is probably important for a commercial website.
However, to keep our examples simple,
we will ignore these requests in this course.
</p>

<p>
Replace your request handling function
with the following code.
</p>

<pre>
function requestListener(req, res) {
  console.log('Handling request for ' + req.url);
  if (req.url === '/') {
    res.end('hello');
  } else {
    res.writeHead(404);
    res.end('Not found.');
  }
}
</pre>

<p>
The above code returns the hello string only for requests for the root resource,
which is named by a single slash in the url component of the HTTP request message.
For all other requests, the code returns a machine readable status code of 
<code>404</code> and a human readable message <em>not found</em> in the body of the
response message.
</p>

<p>
Note that the default status code that Node.js will return is <code>200</code>.
That's the reason we didn't specify this when returning the hello string.
We could have written the code as follows to be more explicit.
</p>

<pre>
res.writeHead(200);
res.end('hello');
</pre>

<h2>Anonymous functions</h2>

<p>
In Javascript, functions are objects and are commonly treated as such, 
especially in the form of callback functions where they are passed in as arguments.
</p>

<p>
When you read documentation and look at code samples, 
you will also commonly see unnamed functions used directly in code where they are defined.
Because they are defined without a name, they are called <em>anonymous functions</em>. 
</p>

<p class="csusbdt-callout">
Anonymous functions are named by the functions that take them as arguments,
but these names are local to the called function.
</p>

<p>
In documentation and articles, you might see the server code presented above 
written with an anonymous function as follows.
</p>

<pre>
server.on('request', function (req, res) {
  console.log('Handling request for ' + req.url);
  if (req.url === '/') {
    res.writeHead(200);
    res.end('hello');
  } else {
    res.writeHead(404);
    res.end('Not found.');
  }
});
</pre>

<p>
The definition of the function that was formerly named <code>requestListener</code> 
is passed directly as an argument to the <code>on</code> function 
without the need of assigning a name to it.
</p>

<p>
Modify your code so that your request handler
is passed into the <code>on</code> function as an anonymous function.
</p>

<h2>Error handling</h2>

<p>
The material for this section comes from 
<a href="http://nodejs.org/api/all.html#all_domain">the Domain section of the Node.js documentation</a>. 
According to this documentation, when Javascript throws an error, 
the virtual machine may start to leak memory and result in other problems. 
For this reason, we should avoid writing code 
that relies on exceptions being thrown as part of its normal operation.
</p>

<p>
The issue with a Node.js Web server is 
that an uncaught exception will shut down the process, 
which shuts off service to all clients as soon as a single uncaught exception occurs.
To avoid loss of service, we should catch and report the exception 
without shutting down the process. 
The following code demonstrates a way to do this using 
<a href="http://nodejs.org/api/all.html#all_domain">Domains</a>.
</p>

<pre>
var http = require('http');
var domain = require('domain');

function replyError(res) {
  try {
    res.writeHead(500);
    res.end('Server error.');
  } catch (err) {
    console.error('Error sending response with code 500.');
  }
};

function handleRequest(req, res) {
  console.log('Handling request for ' + req.url);
  if (req.url === '/') {
   res.end('hello');
  } else {
    res.writeHead(404);
    res.end('Not found.');
  } 
}

var server = http.createServer();

server.on('request', function(req, res) {
  var d = domain.create();
  d.on('error', function(err) {
    console.error(req.url, err.message);
    replyError(res);
  });
  d.run(function() { handleRequest(req, res); });
});

server.listen(5000);
</pre>

<p>
Any errors thrown while handling a given request 
will be caught by a domain object 
specific to the request 
in order to avoid halting the server.
</p>

<p>
Replace <em>main.js</em> with the 
above version of the server code and test that it runs correctly.
</p>

<p>
At this point,
we have only verified that the server works correctly when there
is not error.
We will now create a test to see that our
error catching code works by artificially throwing an error
for every other request for the root resource.
Start by making a copy of <em>main.js</em>;
call the new file <em>test_domain.js</em>.
</p>

<p>
In <em>test_domain.js</em>, declare a variable
that we will use to toggle between throwing and not throwing an error.
</p>

<pre>
var throwError = true;
</pre>

<p>
Use the following code as a guide on how to
throw an error for every other request 
for the root resource.
</p>

<pre>
if (req.url === '/') {
  throwError = !throwError;
  if (throwError) throw new Error("I'm bad.");
...
</pre>

<p>
Run <em>test_domain.js</em> and verify that the
server toggles between returning a normal response
and an error response.
Do this be clicking the browser's refresh button.
</p>

<h2>Refactor</h2>

<p>
In <em>main.js</wm>, simplify <code>handleRequest</code> by moving the 
404 response code into a function named <code>replyNotFound</code>. 
Use the implementation of <code>replyError</code> as a model.
</p>

