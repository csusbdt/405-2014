---
layout: assignment
title: Read Assignment
---

<div class="csusbdt-video-btn">
  <a class="btn btn-success" role="button" target="_blank" href="http://youtu.be/fXshTqi_Xcg">Video</a>
</div>

<h2>Overview</h2>

<p>
The purpose of this assignment is 
to learn how to read documents from a CouchDB database 
from inside a Node.js program.  
This will also give you experience accessing 
remote services using HTTP.
Such services are sometimes referred to as <em>Web services</em>
and are very common in software systems these days.
</p>

<p>
This assignment builds on the ajax and couch assignments.
In the ajax assignment, 
we created a Web page that uses ajax 
to request a message string from the server, 
which it displays to the user. 
However, the message string 
was hard-coded into the program. 
In this assignment, we will 
use what we learned in the couch assignment
to retrieve the message string 
from a CouchDB database.
</p>

<h2>Assignment Folder</h2>

<p>
Create a directory named <em>read</em> 
for the work you do for this assignment. 
At the end of the assignment, 
this folder will contain the following files.
</p>

<ul>
<li>app.html</li>
<li>createdb.bat (if on Windows) or createdb.sh (if on OS X or Linux)</li>
<li>db.js</li>
<li>image.js</li>
<li>main.js</li>
<li>message.js</li>
<li>response.js</li>
<li>root.js</li>
<li>test_update.bat (if on Windows) or test_update.sh (if on OS X or Linux)</li>
<li>image.png</li>
</ul>

<h2>Reading</h2>

<ul>
<li>Read the Node.js documentation related to making HTTP requests,
    starting from  
    <a href="http://nodejs.org/api/http.html#http_http_request_options_callback">http.request</a>.
</li>
</ul>

<h2>Instructions</h2>

<h3>Step One: Copy Existing Code</h3>

<p>
Copy your app server code from the cache assignment 
to the <em>read</em> folder as a starting point.
</p>

<p>
Start your CouchDB server if not already started.
</p>

<p>
Test that the application is working correctly by visiting 
<a href="http://localhost:5000/">http://localhost:5000/</a> 
in a browser.
</p>

<h3>Step Two: Create Stubs</h3>

<p>
In this step we create a partially implemented
module named <code>db</code> that provides a layer of abstraction
between the request handlers and the database.
The <code>db</code> module exports 
a single function named <code>getMessage</code>.
We also modify <code>message</code>, 
the module that handles requests for the message.
Actual interaction with the database will be done in a later step.
</p>

<p>
Create <em>db.js</em> with the following contents.
</p>

<pre>
exports.getMessage = function(cb) {
  cb(null, Math.random() + '');
};
</pre>

<p>
The <code>getMessage</code> function is implemented as a <em>stub</em>
for this intermediate step of development.
The purpose of this function is to retrieve a message string
from the database.
If for whatever reason there is a problem getting this string,
the callback function <code>cb</code> is called with 
an instance of <code>Error</code> as its sole argument.
If there is no problem, then <code>cb</code> is called
with <code>null</code> as its first argument and the message string
as its second argument.
</p>

<p>
We use the random number generator to simulate changing message data.
The <code>random</code> function returns a number,
which we convert to a string by concatinating with the empty string.
</p>

<p>
There is one issue with the stub code for 
the getMessage function: it invokes the callback immediately.
When interacting with the database, we will need to invoke
asynchronous functions,
which means we will return from <code>getMessage</code> <em>before</em> the callback
<code>cb</code> is called.
But our stub code returns from <code>getMessage</code> <em>after</em> 
the callback <code>cb</code> is called.
As a result, the stub code might permit logic errors
that could be caught at this point.
The following code is an improved version of the stub code.
</p>

<pre>
exports.getMessage = function(cb) {
  setTimeout(function() {
    cb(null, Math.random() + '');
  }, 4);
};
</pre>

<p>
The above version of <code>getMessage</code> has the function
returning before the callback is invoked,
which is the normal sequence of events with asynchronous functions.
</p>

<p>
Another improvement we can make
is to alternate between returning an error
and returning a message.
This will test our error hanlding code.
The following version of the stub code accomplishes this.
<p>

<pre>
var error = false;

exports.getMessage = function(cb) {
  setTimeout(function() {
    if (error) cb(new Error('database server error'));
    else cb(null, Math.random() + '');
    error = !error;
  }, 4);
};
</pre>

<p>
With our database code stubbed out,
we can now make changes to the message request handing code,
which is in the module <code>message</code>.
The following code is a rewrite of this
module so that the <code>getMessage</code> function
of the <code>db</code> module is used to get the message to return to the client.
</p>

<pre>
var http = require('http');
var db = require('./db');

exports.handle = function(req, res) {
  db.getMessage(function(err, message) {
    if (err) {
      console.log(err.message);
      res.writeHead(500, 'server error');
      res.end();
      return;
    }
    var responseObject = { msg: message };
    var responseString = JSON.stringify(responseObject);
    var responseBody = new Buffer(responseString, 'utf-8');
    res.writeHead(200, {
      'Content-Type': 'application/json',
      'Content-Length': responseBody.length,
      'Pragma': 'no-cache',
      'Cache-Control': 'no-cache, no-store'
    });
    res.end(responseBody);
  });
};
</pre>

<p>
Note that we <code>require</code> the <code>db</code> module
using an absolute pathname <code>'./db'</code>.
We do this because Nodejs does not search the current directory
when resolving references to modules.
</p>

<p>
Also note that we need to create a <code>Buffer</code> object
for each request. This is required because
the message data may change between requests.
</p>

<p>
Test your implementation by running the server and testing with a browser.
</p>

<h3>Step Three: Write Test Database Creation Script</h3>

<p>
Use what you learned from the CouchDB assignment 
to modify the file <em>createdb.sh</em> 
to create a database called <em>read</em>.
Insert a single document into this database
with a property named <em>text</em>.
This property should be set to the string "the read assignment".
Also, specify the value <em>message</em> for the <code>_id</code> 
field so that we can identify
this document in a straightforward way.
</p>

<p>
Modify <em>test_update.sh</em> so that it changes
the message in the database to "the new message".
</p>

<h3>Step Four: Complete the Database Module</h3>

<p>
Replace the stub code in <code>db.js</code>
with the following code.
</p>

<div class="csusbdt-code-title">db.js</div>

<pre>
var assert      = require('assert');
var querystring = require('querystring');
var http        = require('http');

exports.getMessage = function(cb) {
  var options = {
      hostname: 'localhost',
      auth: 'admin:1234',
      port: 5984,
      path: '/read/message',
      method: 'GET'
  };
  send(options, function(err, data) {
    if (err) {
      console.log(err.message);
      return cb(err);
    }
    if (data.text === undefined) {
      throw new Error(
        'text property missing from msg document.\n' + JSON.stringify(data)
      );
    }
    cb(null, data.text);
  });
};

// Send request and receive data (a Javascript object).
// The options argument is the same as for http.request.
// cb = function(err, data)
function send(options, cb) {
  var req;

  // create request
  req = http.request(options, function(res) {
    var dataString;  // to be converted to Javascript object

    // tell node how to convert received bytes to a Javascript string
    res.setEncoding('utf8');

    // accumulate data
    res.on('data', function (chunk) {
      if (dataString === undefined) dataString = chunk; else dataString += chunk;
    });

    // parse received data
    res.on('end', function() {
      var data;
      try {
        data = JSON.parse(dataString);
      } catch (err) {
        return cb(err);
      }
      cb(null, data);
    });
  });

  // register error listener
  // pass error directly to callback
  req.on('error', cb);

  // send request
  req.end();
};
</pre>

<p>
The <code>db.getMessage</code> function calls the <code>send</code> function,
which calls the Node.js <code>request</code> function 
from the <code>http</code> module.
The <code>request</code> function returns an instance of <code>ClientRequest</code>.
This is used to send an HTTP message to the database server.
So, in this part of our code,
our Web server plays the role of a Web client.
</p>

<p>
First, test that the browser gets the current message from our server
and the server code runs without error.
</p>

<p>
Second, while our server is running,
run <em>test_update.sh</em> to set a 
different message.
Then click on the <em>make a request</em> link
to see that the new message
is displayed to the user.
Do this test without restarting the Web application server.
</p>

