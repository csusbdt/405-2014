---
layout: assignment
title: Buffers Assignment
---

<div class="csusbdt-video-btn">
  <a class="btn btn-success" role="button" target="_blank" href="http://youtu.be/9C7W8Pjhlto">Video</a>
</div>

<h2>Overview</h2>

<p>
The purpose of this assignment is to learn
how to use the Node.js <code>Buffer</code> class
to work with chunks of raw data.
In this assignment, we create an instance of <code>Buffer</code>
to hold the data for a string that is defined in code.
In later assignments, the contents of buffers will come from files.
</p>

<p>
To better understand this assignment,
you should read
<a href="http://nodejs.org/api/all.html#all_buffer">the Node.js documentation on buffers</a>.
</p>

<h2>Assignment folder</h2>

<p>
Create a directory named <em>buf</em> 
in your repository to hold the work for this assignment. 
When you complete this assignment, 
the contents of this folder will be the following.
</p>

<ul>
<li>main.js</li>
<li>root.js<l/i>
</ul>

<h2>Instructions</h2>

<p>
Create a file named <code>main.js</code> with the following contents.
</p>

<pre>
var http = require('http');
var domain = require('domain');
var root = require('./root');

function replyError(res) {
  try {
    res.writeHead(500);
    res.end('Server error.');
  } catch (err) {
    console.error('Error sending response with code 500.');
  }
};

function replyNotFound(res) {
  res.writeHead(404);
  res.end('not found');
}

function handleRequest(req, res) {
  console.log('Handling request for ' + req.url);
  if (req.url === '/') {
    root.handle(req, res);
  } else {
    replyNotFound(res);
  }
}

var server = http.createServer();

server.on('request', function(req, res) {
  var d = domain.create();
  d.on('error', function(err) {
    console.error(req.url, err.message);
    replyError(res);
  });
  d.run(function() { handleRequest(req, res); });
});

server.listen(5000);
</pre>

<p>
The above main module code incorporates the domain-based error handling 
that we covered in a previous assignment.
It adds a <code>replyNotFound</code> function, 
which sends a response to the client when the client 
requests a resource that the server does not recognize. 
HTTP responses include 3-digit codes;
A code value of 404 signifies that a resource is not found.
</p>

<p>
The main module also delegates the processing 
of requests for the root resource path <code>/</code> to a module named <code>root</code>.
The next step is to implement the root module.
</p>

<p>
Create file <code>root.js</code> with the following contents.
</p>

<pre>
var http = require('http');

var body = new Buffer("I'm a codfish.", 'utf-8');

exports.handle = function(req, res) {
  res.writeHead(200, {
    'Content-Type': 'text/plain; charset=UTF-8'
  });
  res.end(body);
};
</pre>

<p>
In <em>root.js</em>, we create a buffer object to store a string in the UTF-8 character encoding. 
The UTF-8 encoding is the default encoding,
so we could have written the following.
</p>

<pre>
var body = new Buffer("I'm a codfish.");
</pre>

<p>
However, our code is explicit about the encoding as a form of documentation.
</p>

<p>
We use the name <code>body</code> to store the string 
because it will comprise the body of the HTTP message sent to the browser.
</p>

<p>
When we return the message data to clients,
we include a header that indicates 
the data is of type <em>text/plain</em>.
You shoud read <a href="http://en.wikipedia.org/wiki/Internet_media_type">Internet Media Types</a>
to become familiar with this concept and the standard labels.
</p>

<p>
Following the content type name is a semicolon followed by <code>charset=UTF-8</code>.
When sending character data such as <em>text/plain</em> and <em>text/html</em>,
the browser needs to know which character set should be used to
map byte values to characters.
The default character set for strings sent over HTTP is UTF-8,
which is a variable length representation of characters.
Other character sets are common in other situations.
For example, Java programs represent strings internally using
the UTF-16 encoding, which is a fixed-length encoding.
Javascript uses it own character encoding that is mostly identical to UTF-8
with exceptions for some uncommon characters.
</p>

<p>
Although UTF-8 is the encoding normally assumed by browsers if not otherwise specified,
we include it anyway to ensure that the client interprets the character data correctly.
</p>

<p>
Test the server code and debug so that it runs correctly.
</p>

<p>
Node.js uses <a href="http://en.wikipedia.org/wiki/Chunked_transfer_encoding">chunked encoding</a> 
by default to send data in the body of HTTP messages.
Run your server and verify this
with the Web developer tools available for your browser.  
A good place to learn about how to use the developer tools built into Chrome is 
<a href="http://discover-devtools.codeschool.com">the Dev-tools course on Code School</a>.
If you are using a different browser,
you will need to locate similar documentation and spend time to learn
how to use its Web developer tools.
</p>

<p class="csusbdt-callout">
It is essential to learn the Web developer tools for at least one browser.
</p>

<p>
The alternative to sending data with chunked encoding 
is to set a <code>Content-Length</code> header. 
The content length header tells the receiveing end exactly how many
bytes are included in the body of the HTTP message.
Research the HTTP Content-Length header and then
modify the root module to send the content type 
instead of the chunked encoding.
I will evaluate your work on this assignment by whether your server code
runs correctly with the Content-Length header
and satisfies the code readability criteria described in the syllabus.
</p>

